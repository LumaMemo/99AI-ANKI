# 99AI-ANKI 知识库（PDF 上传到腾讯云 COS 私有）开发路线图

日期：2025-12-17

基于 [99AI-ANKI/docs/设计方案.md](99AI-ANKI/docs/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.md) 的落地计划。

已确定产品/实现选择：

- 文件夹删除：仅允许删除空文件夹（A）
- 私有读取：返回签名 URL（A）
- 免费用户默认配额：50MB（B）

---

## 0. 前置约定（不算 Step）

- DB：MySQL（或兼容），后端使用 TypeORM；本文以 SQL 方式增量改表，确保每步都可独立验证。
- 鉴权：chat 端接口全部走 `JwtAuthGuard`（需要 `Authorization: Bearer <token>`）。
- 命名：新功能统一前缀 `/api/kb`。
- COS SDK：复用已存在依赖 `cos-nodejs-sdk-v5`。

### 0.1 当前代码落地情况（已核对）

- DB（MySQL + TypeORM）：已在 [service/src/modules/database/database.module.ts](../service/src/modules/database/database.module.ts) 里通过 `TypeOrmModule.forRootAsync` 使用 `type: 'mysql'`，并显式注册 entity；`synchronize: false`，符合“SQL 增量改表、每步可独立验证”的要求。
- `/api` 前缀：已在 [service/src/main.ts](../service/src/main.ts) 通过 `app.setGlobalPrefix('/api', ...)` 设置，全局 API 基础路径与本文档一致。
- 鉴权（JWT Guard）：已存在 [service/src/common/auth/jwtAuth.guard.ts](../service/src/common/auth/jwtAuth.guard.ts)；现有多个 controller 已在路由上使用 `@UseGuards(JwtAuthGuard)`，KB 新接口将沿用同一 guard。
  - 备注：当前 guard 除 `Authorization: Bearer <token>` 外，还支持 `fingerprint` header 生成 token（用于兼容部分场景）。KB 接口默认仍按 Bearer token 联调。
- COS SDK：已在 [service/package.json](../service/package.json) 声明依赖 `cos-nodejs-sdk-v5`，KB 模块将直接复用该依赖（不新增包）。

---

## 1) 修改后的 API 接口定义（最终形态）

> Base URL：`{SERVICE_BASE}/api`

### 1.1 配额

- `GET /kb/quota`
  - Auth：JWT
  - 响应：
    ```json
    {
      "quotaBytes": 52428800,
      "usedBytes": 123456,
      "remainingBytes": 52305344
    }
    ```

### 1.2 文件夹

- `GET /kb/folders/tree`

  - Auth：JWT
  - 响应（示例）：
    ```json
    {
      "id": 0,
      "name": "根目录",
      "children": [
        { "id": 1, "name": "work", "children": [] }
      ]
    }
    ```
- `POST /kb/folders`

  - Auth：JWT
  - Body：`{ "parentId": 0, "name": "work" }`
  - 响应：folder 记录
- `PATCH /kb/folders/:id`

  - Auth：JWT
  - Body：`{ "name": "newName" }`
- `DELETE /kb/folders/:id`

  - Auth：JWT
  - 规则：仅允许删除空文件夹（若存在子文件夹或文件，返回 400）

### 1.3 文件（PDF）

- `GET /kb/files?folderId=0&page=1&size=20`

  - Auth：JWT
  - 响应：
    ```json
    {
      "rows": [
        {
          "id": 10,
          "folderId": 0,
          "displayName": "深度学习导论",
          "originalName": "深度学习导论.pdf",
          "sizeBytes": 123456,
          "createdAt": "2025-12-17T00:00:00.000Z"
        }
      ],
      "count": 1
    }
    ```
- `POST /kb/files/upload?folderId=0`

  - Auth：JWT
  - Content-Type：`multipart/form-data`
  - form field：`file`（仅 PDF）
  - 响应：file 记录（不直接返回永久公网 URL）
- `PATCH /kb/files/:id`

  - Auth：JWT
  - Body：`{ "displayName": "新名字" }`
- `DELETE /kb/files/:id`

  - Auth：JWT
- `GET /kb/files/:id/signed-url`

  - Auth：JWT
  - 响应：
    ```json
    {
      "url": "https://<cos-domain>/<key>?...signature...",
      "expiresAt": 1734412345
    }
    ```

---

## Step 1：数据库增量（新增表 + 套餐字段）

### 目标

- 新增：`kb_folder`、`kb_pdf`、`kb_user_usage`
- 扩展：`crami_package` 增加 `kbQuotaBytes`（bigint）

### 交付物

- 代码落地：通过 TypeORM 实体 + 启动时 `synchronize: true` 自动创建/补齐表结构（部署“一次性搞定”）

### 实施（代码方式：实体 + synchronize）

本项目 DB 初始化的“原始方式”是：启动时执行 `initDatabase()`，随后用 TypeORM `synchronize: true` 确保新表/新字段自动创建。

本次 Step 1 已按该方式落地，不再在 `initDatabase.ts` 里手写 `CREATE TABLE`。

### 验证方法

- 验证字段：

```sql
SHOW COLUMNS FROM crami_package LIKE 'kbQuotaBytes';
```

- 验证表：

```sql
SHOW TABLES LIKE 'kb_%';
```

### 本步骤状态

- 已完成：通过 TypeORM 实体 + `synchronize` 自动创建 `kb_*` 三表，并在 `crami_package` 增加 `kbQuotaBytes`。

### 部署一键化（已集成）

- 已将 Step 1 的“表/字段补齐”完全交给 TypeORM `synchronize`：
  - 启动时执行 [service/src/modules/database/initDatabase.ts](../service/src/modules/database/initDatabase.ts) 的初始化流程，最终用 `synchronize: true` 自动创建/更新结构。
  - 运行态 TypeORM 连接（Module 注入）同样显式注册了 KB 实体，避免漏表。

本次涉及的 6 个代码文件（与当前实现完全一致）：

- [service/src/modules/database/initDatabase.ts](../service/src/modules/database/initDatabase.ts)（已移除 KB 手写建表；改为实体驱动同步）
- [service/src/modules/database/database.module.ts](../service/src/modules/database/database.module.ts)（显式 entities 列表加入 KB 三实体）
- [service/src/modules/crami/cramiPackage.entity.ts](../service/src/modules/crami/cramiPackage.entity.ts)（新增 `kbQuotaBytes` 字段）
- [service/src/modules/kb/kbFolder.entity.ts](../service/src/modules/kb/kbFolder.entity.ts)（新增 `kb_folder` 实体）
- [service/src/modules/kb/kbPdf.entity.ts](../service/src/modules/kb/kbPdf.entity.ts)（新增 `kb_pdf` 实体）
- [service/src/modules/kb/kbUserUsage.entity.ts](../service/src/modules/kb/kbUserUsage.entity.ts)（新增 `kb_user_usage` 实体）

### 变更说明（与你反馈对齐）

- `crami_package.kbQuotaBytes` 已改为由 TypeORM 实体初始化/同步时直接创建：
  - [service/src/modules/crami/cramiPackage.entity.ts](../service/src/modules/crami/cramiPackage.entity.ts)
- `initDatabase.ts` 不再对 `crami_package` 做单独 `ALTER TABLE`，避免“首次部署时表尚未创建导致 ALTER 失败”。
- `initDatabase.ts` 不再手写 KB 三表 `CREATE TABLE`，完全按项目原有方式（实体 + `synchronize`）自动创建。

### 回滚策略

- 快速回滚 SQL（如需手动回滚结构）：

```sql
DROP TABLE IF EXISTS kb_user_usage;
DROP TABLE IF EXISTS kb_pdf;
DROP TABLE IF EXISTS kb_folder;
ALTER TABLE crami_package DROP COLUMN kbQuotaBytes;
```

---

## Step 2：后端仅新增 Entity（不加接口）

### 目标

- 在 service 侧新增 TypeORM 实体：`KbFolderEntity`、`KbPdfEntity`、`KbUserUsageEntity`
- 扩展 `CramiPackageEntity` 增加 `kbQuotaBytes`

### 交付物

- entity 文件（不注册路由，不新增 controller）

### 本步骤状态

- 已完成：KB 三个实体已新增；`CramiPackageEntity` 已扩展 `kbQuotaBytes`。
- 已完成：由于本项目 TypeORM 采用“显式 entities 列表”方式，已把 KB 三实体加入以下两处注册点，确保后续 `synchronize`/运行态连接都能识别这些表：
  - [service/src/modules/database/initDatabase.ts](../service/src/modules/database/initDatabase.ts)
  - [service/src/modules/database/database.module.ts](../service/src/modules/database/database.module.ts)

本次涉及的 4 个新增/修改 entity 文件：

- [service/src/modules/kb/kbFolder.entity.ts](../service/src/modules/kb/kbFolder.entity.ts)
- [service/src/modules/kb/kbPdf.entity.ts](../service/src/modules/kb/kbPdf.entity.ts)
- [service/src/modules/kb/kbUserUsage.entity.ts](../service/src/modules/kb/kbUserUsage.entity.ts)
- [service/src/modules/crami/cramiPackage.entity.ts](../service/src/modules/crami/cramiPackage.entity.ts)

### 验证方法

- 编译验证（确保类型/装饰器没问题）：

  - Windows（推荐用 cmd，避免 PowerShell 执行策略影响）：
    - `cd 99AI-ANKI\service && pnpm -s build`
  - PowerShell（若你的环境 pnpm 被映射到 pnpm.ps1 导致无法执行）：
    - `cd 99AI-ANKI\service; pnpm.cmd -s build`
- DB 结构验证（可选，依赖你已启动过 service 并跑过 initDatabase + synchronize）：

```sql
SHOW TABLES LIKE 'kb_%';
SHOW COLUMNS FROM crami_package LIKE 'kbQuotaBytes';
```

### 自检清单

- 新增依赖：无（仅新增 TypeORM entity 文件，复用现有依赖）。
- 旧数据兼容：
  - 新增表不影响旧表数据；
  - `crami_package.kbQuotaBytes` 为新增列且默认 0，不会破坏既有行。

### 回滚策略

- 删除新增 entity 文件
- 恢复 `CramiPackageEntity` 改动

---

## Step 3：后端仅新增 DTO + Module 骨架（接口返回占位）

### 目标

- 新增 `KbModule`，注册到 AppModule
- 新增 Controller 路由 `/kb/*`（先返回固定占位 JSON，不落库）

### 交付物

- `KbModule` + `KbController`（占位接口）
- DTO（响应结构占位，用于后续逐步替换为真实实现）

### 本步骤状态

- 已完成：已注册 `KbModule` 到 AppModule，`/api/kb/*` 路由可访问（需要 JWT）。

本次涉及文件：

- [service/src/modules/kb/kb.module.ts](../service/src/modules/kb/kb.module.ts)
- [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- [service/src/modules/kb/dto/kbQuota.dto.ts](../service/src/modules/kb/dto/kbQuota.dto.ts)
- [service/src/modules/kb/dto/kbFolderTree.dto.ts](../service/src/modules/kb/dto/kbFolderTree.dto.ts)
- [service/src/modules/kb/dto/kbFileList.dto.ts](../service/src/modules/kb/dto/kbFileList.dto.ts)
- [service/src/app.module.ts](../service/src/app.module.ts)

### 占位接口清单

- `GET /api/kb/quota`：返回 `{ quotaBytes: 0, usedBytes: 0, remainingBytes: 0 }`
- `GET /api/kb/folders/tree`：返回根节点 `{ id:0, name:'根目录', children:[] }`
- `GET /api/kb/files`：返回空分页 `{ rows: [], count: 0 }`

### 验证脚本（curl）

test token：Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM

> `TOKEN` 替换为真实 JWT。测试的端口参考.env的后端方服务端口

```bash
curl -H "Authorization: Bearer TOKEN" http://localhost:9520/api/kb/quota
```

预期：返回 200，固定占位结构（例如 quota=0/used=0）。

（可选）验证其他占位接口：

```bash
curl -H "Authorization: Bearer TOKEN" http://localhost:9520/api/kb/folders/tree
curl -H "Authorization: Bearer TOKEN" "http://localhost:9520/api/kb/files?folderId=0&page=1&size=20"
```

### 自检清单

- 新增依赖：无（仅新增 Nest module/controller + DTO 文件）。
- 旧数据兼容：完全兼容（本步骤不访问 DB、不读写数据）。

### 编译验证（推荐）

- Windows（cmd，避免 PowerShell 执行策略影响）：`cd 99AI-ANKI\service && pnpm -s build`
- PowerShell（若 pnpm 被映射到 pnpm.ps1 无法执行）：`cd 99AI-ANKI\service; pnpm.cmd -s build`

### 回滚策略

- 从 AppModule 移除 KbModule
- 删除 module/controller/dto 文件

---

## Step 4：配额计算（GET /kb/quota 真正可用）

### 目标

- 实现：
  - `quotaBytes`：
    - 若用户无套餐（`user_balances.packageId=0` 或不存在）：默认 `50MB = 50*1024*1024`
    - 否则读取 `crami_package.kbQuotaBytes`
  - `usedBytes`：优先读 `kb_user_usage.usedBytes`，不存在则初始化为 0

### 验证脚本

1) SQL：给一个套餐设置 200MB

```sql
UPDATE crami_package SET kbQuotaBytes = 209715200 WHERE id = 1;
```

2) curl：用购买了该套餐的用户请求

```bash
curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" http://localhost:9520/api/kb/quota
```

预期：`quotaBytes=209715200`。

### 本步骤状态

- 已完成：`GET /api/kb/quota` 已从占位改为真实计算。
  - `quotaBytes`：
    - `user_balances` 不存在或 `packageId=0`：默认 `50MB`
    - 否则读取 `crami_package.kbQuotaBytes`
  - `usedBytes`：优先读 `kb_user_usage.usedBytes`；不存在则自动初始化为 0

本次涉及文件：

- [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)
- [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- [service/src/modules/kb/kb.module.ts](../service/src/modules/kb/kb.module.ts)

### 自检清单

- 新增依赖：无（仅新增 service 文件，复用现有 TypeORM/Nest 依赖）。
- 旧数据兼容：
  - `kb_user_usage` 记录不存在时会自动插入一行（`usedBytes=0`），不影响旧业务表；
  - 未改动原有扣费/套餐逻辑，仅读取 `user_balances.packageId` 与 `crami_package.kbQuotaBytes`。

### 编译验证（推荐）

- Windows（cmd）：`cd 99AI-ANKI\service && pnpm.cmd -s build:test`

### 回滚策略

- 代码回滚：恢复 quota 计算逻辑为占位
- 数据回滚：把 `crami_package.kbQuotaBytes` 设回 0

---

## Step 5：文件夹树（GET/POST/PATCH/DELETE 文件夹）

### 目标

- 完整实现：
  - 创建文件夹（同级不重名）
  - 重命名
  - 查询树
  - 删除（仅允许空文件夹删除：无子文件夹、无 kb_pdf）

### 本步骤状态

- 已完成：文件夹树与文件夹 CRUD 已落地。
  - 查询树：`GET /api/kb/folders/tree` 返回当前用户的树形结构（根节点固定 `id=0`）。
  - 创建：`POST /api/kb/folders` 支持 `parentId`（默认 0），并保证同级不重名。
  - 重命名：`PATCH /api/kb/folders/:id` 支持同级不重名；同时会同步更新后代 folder 的 `path` 前缀。
  - 删除：`DELETE /api/kb/folders/:id` 仅允许删除空文件夹（无子文件夹、且不存在未删除的 kb_pdf）。

本次涉及文件：

- [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)
- [service/src/modules/kb/kb.module.ts](../service/src/modules/kb/kb.module.ts)
- [service/src/modules/kb/dto/kbFolderCreate.dto.ts](../service/src/modules/kb/dto/kbFolderCreate.dto.ts)
- [service/src/modules/kb/dto/kbFolderRename.dto.ts](../service/src/modules/kb/dto/kbFolderRename.dto.ts)

### 验证脚本

1) 创建：

```bash
curl -X POST "http://localhost:9520/api/kb/folders" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" -H "Content-Type: application/json" -d "{\"parentId\":0,\"name\":\"work\"}"
```

> 预期：首次创建返回 200；如果已经存在同名文件夹，会返回 400（`同级已存在同名文件夹`），属于正常校验结果。

2) 树：

```bash
curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" "http://localhost:9520/api/kb/folders/tree"
```

> 从返回的 tree 里找到你要操作的文件夹 `id`（例如你创建的 `work` 可能是 `id=1`）。下面的 `ID` 必须替换成真实数字。

2.1) 重命名：

```bash
curl -X PATCH "http://localhost:9520/api/kb/folders/1" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" -H "Content-Type: application/json" -d "{\"name\":\"work2\"}"
```

3) 删除（空文件夹应成功）：

```bash
curl -X DELETE -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" "http://localhost:9520/api/kb/folders/1"
```

（可选）删除非空文件夹应失败：

- 先创建子文件夹或插入一条 kb_pdf 记录，再 delete，应返回 400。

### 自检清单

- 新增依赖：无（仅新增 DTO 文件与 folder 相关逻辑，复用现有 Nest/TypeORM/class-validator）。
- 旧数据兼容：兼容（新增表不影响旧表；本步骤仅读写 `kb_folder`/`kb_pdf`）。

### 编译验证（推荐）

- Windows（PowerShell）：`cd 99AI-ANKI\service; pnpm.cmd -s build:test`

### 回滚策略

- 代码：回退 folder controller/service
- 数据：

```sql
DELETE FROM kb_folder WHERE userId = <YOUR_USER_ID>;
```

---

## Step 6：PDF 列表分页（GET /kb/files）

### 目标

- 在 `folderId` 维度分页查询“当前登录用户”的 PDF 列表（只查自己的）。
  - 输入：`folderId`（文件夹）、`page`（页码）、`size`（每页条数）
  - 输出：分页结构 `{ rows, count }`
    - `rows`：当前页数据（最多 `size` 条）
    - `count`：总条数（同一筛选条件下的总数，用于前端分页）

### 本步骤状态

- 已完成：`GET /api/kb/files` 已从占位改为真实分页查询。
  - 过滤维度：`userId + folderId`
  - 分页参数：`page`（默认 1）、`size`（默认 20，最大 100）
  - 排序：`createdAt DESC`
  - 过滤：排除 `status=3`（deleted）

### 成功判定（你测的时候看这些）

- 请求成功返回 200（外层 `code=200`）。
- `data.rows` 里能看到该用户/该 folderId 的记录。
- `data.count` 是总数，且与数据插入量一致（在同一筛选条件下）。
- `page/size` 改变时：
  - `page=2` 可能返回空 `rows`，但 `count` 仍是总数（不变）。
- `status=3` 的记录不会出现在 `rows` 里。

本次涉及文件：

- [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)

### 验证脚本

- 先插入一条假数据（仅测试环境）：

```sql
INSERT INTO kb_pdf(userId, folderId, displayName, originalName, ext, mimeType, sizeBytes, cosBucket, cosRegion, cosKey, status, createdAt, updatedAt, deletedAt)
VALUES (1, 0, 'demo', 'demo.pdf', 'pdf', 'application/pdf', 100, 'b', 'r', 'k', 1, NOW(), NOW(), NULL);
```

> 注意：`deletedAt` 必须为 `NULL`（否则会被视为“已软删除”，列表接口默认查不到）。

- curl：

```bash
curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImYwY2IxNjVlYiIsImlkIjoyLCJlbWFpbCI6IjExMzI2NTAxMDhAcXEuY29tIiwicm9sZSI6InZpZXdlciIsIm9wZW5JZCI6IiIsImNsaWVudCI6bnVsbCwicGhvbmUiOiIiLCJpYXQiOjE3NjU3MDAyNDAsImV4cCI6MTc2NjMwNTA0MH0.qccI5V-Qt7MQf_nqAKP9dX-qs5fS8JNwDR26tscp5VM" "http://localhost:9520/api/kb/files?folderId=0&page=1&size=10"
```

### 自检清单

- 新增依赖：无（复用现有 Nest/TypeORM）。
- 旧数据兼容：兼容（仅读取 `kb_pdf`，不改动历史数据；过滤已删除 `status=3`）。

### 编译验证（推荐）

- Windows（PowerShell）：`cd 99AI-ANKI\service; pnpm.cmd -s build:test`

### 回滚策略

- 删除测试数据：

```sql
DELETE FROM kb_pdf WHERE displayName='demo';
```

---

## Step 7：KB COS 配置（仅后端读取 + 失败可解释）

### 目标

- 后端通过 `config` 表读取 KB 专属 COS 配置（不复用现有 upload 配置）：
  - `kbTencentCosStatus`
  - `kbCosSecretId` / `kbCosSecretKey`
  - `kbCosBucket` / `kbCosRegion`
  - `kbCosPrefix`（默认 `kb`）
  - `kbCosSignedUrlExpiresSeconds`（默认 600）
  - `kbSinglePdfMaxBytes`（默认 100MB）

### 说明（你问的“这些参数是什么？”）

- 这一步不是“测试 COS key 是否可用”，而是把“知识库功能要用到的 COS 配置”放进统一的 `config` 表里，让后端后续步骤（上传、签名 URL、删除）可以按同一套 key 读取。
- 真正验证 key/bucket/region 是否正确，要到 Step 8（上传到 COS）或 Step 9（生成 signed-url 并访问）才会发生网络请求。
- 这几个 key 的含义：
  - `kbTencentCosStatus`：是否启用 KB 使用 COS（`1` 启用；`0`/空 不启用）
  - `kbCosSecretId` / `kbCosSecretKey`：腾讯云密钥（AK/SK）
  - `kbCosBucket` / `kbCosRegion`：桶名与地域
  - `kbCosPrefix`：对象 key 的统一前缀目录（默认 `kb`，即都放在桶内的 `kb/` 下）
  - `kbCosSignedUrlExpiresSeconds`：签名 URL 有效期（秒），缺省用默认值
  - `kbSinglePdfMaxBytes`：单个 PDF 允许的最大字节数（bytes），缺省用默认值

### 本次代码改动做了什么

- 在后端增加“KB 专属 COS 配置读取器”，从 `config` 表一次性读取 `kb*` keys，并转换为类型安全的配置对象。
- 提供两种读取模式：
  - 宽松模式：读取 + 默认值，但不抛错（用于不依赖 COS 的接口提前 warm-up，比如 `GET /api/kb/quota`）。
  - 严格模式：读取 + 校验 + 可解释报错（用于后续强依赖 COS 的接口，比如上传/签名 URL/删除）。
- 可解释报错示例（后续 Step 8/9/10 会复用）：
  - 未启用：提示把 `kbTencentCosStatus` 设为 `1`
  - 缺少必填：会明确指出缺的 configKey（例如 `kbCosBucket, kbCosRegion`）
  - 数值非法：会提示 `kbCosSignedUrlExpiresSeconds` / `kbSinglePdfMaxBytes` 必须为正整数

### 验证脚本

- SQL 插入（如你的 config 表名为 `config`，字段按现有 `ConfigEntity` 调整）：

```sql
INSERT INTO config(configKey, configVal, createdAt, updatedAt, deletedAt)
VALUES
 ('kbTencentCosStatus','1',NOW(),NOW(),NULL),
 ('kbCosSecretId','<id>',NOW(),NOW(),NULL),
 ('kbCosSecretKey','<key>',NOW(),NOW(),NULL),
 ('kbCosBucket','<bucket>',NOW(),NOW(),NULL),
 ('kbCosRegion','<region>',NOW(),NOW(),NULL),
 ('kbCosPrefix','kb',NOW(),NOW(),NULL),
 ('kbCosSignedUrlExpiresSeconds','600',NOW(),NOW(),NULL),
 ('kbSinglePdfMaxBytes','104857600',NOW(),NOW(),NULL);
```

- 说明：`config.deletedAt` 非 NULL 会被 TypeORM 视为“软删除”，`GlobalConfigService` 初始化读取时会读不到（因此这里必须是 `NULL`）。
- 触发读取：访问 `GET /api/kb/quota` 或后续上传接口（服务启动无报错即可）。

### 本步骤状态

- 已完成：后端已接入 KB 专属 COS 配置读取（不复用 upload 配置），并提供默认值与“可解释”的校验错误。
- 代码位置：
  - `KbService` 内部实现 `getKbCosConfig()`（不抛错，供非 COS 依赖接口 warm-up）与 `getKbCosConfigOrThrow()`（供后续上传/签名 URL 等强依赖 COS 的接口调用）。
  - `GET /api/kb/quota` 会触发一次读取（不影响返回）。
- 编译验证：你本地已执行 `pnpm.cmd -s build:test` 且 webpack 编译成功。

### 回滚策略

- 删除这些 configKey：

```sql
DELETE FROM config WHERE configKey LIKE 'kb%';
```

---

## Step 8：PDF 上传到 COS（POST /kb/files/upload）

### 目标

- 仅允许 PDF
- 校验：单文件上限 + 配额剩余
- 生成 cosKey：`kb/{userId}/{folderPath}/{pdfDisplaySlug}/{fileId}/{originalFileName}.pdf`
- 成功后：
  - `kb_pdf.status=1`
  - `kb_user_usage.usedBytes += sizeBytes`

### 本步骤状态

- 已完成：新增 `POST /api/kb/files/upload?folderId=0`（multipart form-data 的 `file` 字段）。
- 已完成：仅允许 PDF（扩展名 `.pdf` + MIME `application/pdf` + 文件头 `%PDF-` 校验）。
- 已完成：服务端校验“单文件上限（kbSinglePdfMaxBytes）+ 配额剩余（remainingBytes）”。
- 已完成：按规则生成 `cosKey`：`kb/{userId}/{folderPath}/{pdfDisplaySlug}/{fileId}/{originalFileName}.pdf`（根目录 folderPath 使用 `root`）。
- 已完成：上传 COS 成功后写入 `kb_pdf.cosKey/etag/status=1`，并将 `kb_user_usage.usedBytes` 累加 `sizeBytes`。

代码位置：

- 后端路由：`KbController` -> [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- 后端实现：`KbService.uploadPdfToCos()` -> [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)

### 验证脚本

预期：返回结构形如：

```json
{
  "code": 200,
  "data": {
    "rows": [
      {
        "id": 1,
        "folderId": 0,
        "displayName": "demo",
        "originalName": "demo.pdf",
        "sizeBytes": 100,
        "createdAt": "2025-12-17T16:00:00.000Z"
      }
    ],
    "count": 1
  },
  "success": true,
  "message": "请求成功"
}
```

- curl 上传（把 `./a.pdf` 换成真实文件路径）：

```bash
curl -X POST "http://localhost:9520/api/kb/files/upload?folderId=0" \
  -H "Authorization: Bearer TOKEN" \
  -F "file=@./a.pdf"
```

- 验证 DB：

```sql
SELECT id, userId, folderId, displayName, sizeBytes, cosBucket, cosRegion, cosKey, status FROM kb_pdf WHERE userId=<YOUR_USER_ID> ORDER BY id DESC LIMIT 5;
SELECT * FROM kb_user_usage WHERE userId=<YOUR_USER_ID>;
```

### 回滚策略

- 数据回滚：删除该用户的 kb_pdf 记录并回退 usedBytes

```sql
-- 先查出要删的文件 size
SELECT id, sizeBytes FROM kb_pdf WHERE userId=<YOUR_USER_ID> AND status=1;

-- 手动维护 usedBytes（或直接重算）
UPDATE kb_user_usage SET usedBytes=0 WHERE userId=<YOUR_USER_ID>;
DELETE FROM kb_pdf WHERE userId=<YOUR_USER_ID>;
```

- COS 回滚：手动删除对应 `cosKey` 下对象（或写临时清理脚本）。

---

## Step 9：签名 URL（GET /kb/files/:id/signed-url）

### 目标

- 校验 owner
- 返回短期有效 URL（默认 600 秒）

### 本步骤状态

- 已完成：新增 `GET /api/kb/files/:id/signed-url`。
- 已完成：校验 owner（`kb_pdf.userId === req.user.id`），并校验 `status != 3`。
- 已完成：返回短期有效签名 URL，过期秒数取 `kbCosSignedUrlExpiresSeconds`（未配置则走默认值；示例配置为 600 秒）。

代码位置：

- 后端路由：`KbController.signedUrl()` -> [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- 后端实现：`KbService.getFileSignedUrl()` -> [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)

### 验证脚本

1) 获取文件 id：

```bash
curl -H "Authorization: Bearer TOKEN" "http://localhost:9520/api/kb/files?folderId=0&page=1&size=1"
```

2) 获取 signed-url：

```bash
curl -H "Authorization: Bearer TOKEN" http://localhost:9520/api/kb/files/ID/signed-url
```

3) 用返回的 `url` 在浏览器打开（应能预览/下载）。

### 回滚策略

- 临时回滚：接口改为返回 501（Not Implemented）
- 或将过期时间改为极短（例如 5 秒）用于止血

---

## Step 10：删除 PDF（DELETE /kb/files/:id）

### 目标

- 标记 deleting -> 删除 COS 对象 -> 标记 deleted
- `kb_user_usage.usedBytes -= sizeBytes`（下限为 0）

### 本步骤状态

- 已完成：新增 `DELETE /api/kb/files/:id`。
- 已完成：删除流程：先标记 `kb_pdf.status=2(deleting)` -> 删除 COS 对象 -> 标记 `kb_pdf.status=3(deleted)`。
- 已完成：删除成功后 `kb_user_usage.usedBytes -= sizeBytes`，并用 `GREATEST(...,0)` 保证下限为 0。
- 失败策略：若 COS 删除失败，保持 `status=2` 便于后续重试/人工修复。

代码位置：

- 后端路由：`KbController.deleteFile()` -> [service/src/modules/kb/kb.controller.ts](../service/src/modules/kb/kb.controller.ts)
- 后端实现：`KbService.deleteFile()` -> [service/src/modules/kb/kb.service.ts](../service/src/modules/kb/kb.service.ts)

### 验证脚本

```bash
curl -X DELETE -H "Authorization: Bearer TOKEN" http://localhost:9520/api/kb/files/ID
```

验证 DB：

```sql
SELECT id, status FROM kb_pdf WHERE id=ID;
SELECT usedBytes FROM kb_user_usage WHERE userId=<YOUR_USER_ID>;
```

### 测试记录（一次真实联调样例）

- `DELETE /api/kb/files/2` 返回 200（删除成功）。
- 再次 `DELETE /api/kb/files/2` 返回 404（文件已标记 deleted，重复删除按“不存在”处理，属预期）。
- `DELETE /api/kb/files/1` 返回 500，错误：`Bucket should format as "test-1250000000".`
  - 说明：该记录的 `cosBucket` 不符合腾讯云 COS bucket 命名规范（多半是早期“只测数据库未真实上传 COS”的测试数据），因此 COS 删除会失败；此时记录会保持 `status=2(deleting)` 便于后续人工修复/重试。

### 回滚策略

- 如果 COS 删除失败：保持 status=2 并允许重试（手动触发重试接口或后台脚本）
- 紧急止血：先禁用 delete 路由，仅保留列表/预览

---

## Step 11：admin 套餐支持“知识库空间大小”

### 目标

- admin 套餐管理页增加字段输入（MB/GB）
- 后端 `CreatePackageDto/UpdatePackageDto` 支持该字段
- `CramiPackageEntity` 持久化 `kbQuotaBytes`

### 本步骤状态

- 已完成：admin 套餐新增/编辑表单支持输入“知识库空间”（MB/GB），提交时换算为 `kbQuotaBytes` 写入后端。
- 已完成：后端 `CreatePackageDto/UpdatePackageDto` 已接收 `kbQuotaBytes`（可选）。

本次涉及的代码文件：

- [service/src/modules/crami/dto/createPackage.dto.ts](../service/src/modules/crami/dto/createPackage.dto.ts)（新增 `kbQuotaBytes` 字段）
- [admin/src/views/package/package.vue](../admin/src/views/package/package.vue)（表单新增“知识库空间”输入 + 列表展示）

### 验证脚本

1) admin UI 创建/编辑套餐后，SQL 校验：

```sql
SELECT id, name, kbQuotaBytes FROM crami_package ORDER BY id DESC LIMIT 10;
```

### 自检清单

- 新增依赖：无。
- 旧数据兼容：兼容。`kbQuotaBytes` 缺省/历史数据按 0 处理，不影响既有套餐。

### 测试指令（推荐）

- 编译验证（避免 TS/DTO 语法问题）：
  - `cd 99AI-ANKI/service && pnpm -s build`
  - `cd 99AI-ANKI/admin && pnpm -s build`

### 回滚策略

- UI 回滚：隐藏字段（不影响后端）
- 数据回滚：将 `kbQuotaBytes` 统一置 0

---

## Step 12：admin 增加“KB COS 配置”页面（写 config 表）

### 目标

- 新增 admin 页面（建议：存储配置下新增“知识库 COS”）
- 调用现有：`POST /api/config/query` / `POST /api/config/set`
- 配置项为 Step 7 的 `kb*` keys

### 本步骤状态

- 已完成：admin 存储配置下新增“知识库COS”页面，使用 `POST /api/config/query` / `POST /api/config/set` 读写 Step 7 的 `kb*` keys。

本次涉及的代码文件：

- [admin/src/views/storage/kbCos.vue](../admin/src/views/storage/kbCos.vue)（新增页面）
- [admin/src/router/modules/storage.menu.ts](../admin/src/router/modules/storage.menu.ts)（菜单新增入口）

### 验证脚本

- 在 admin 保存后，SQL 校验：

```sql
SELECT configKey, configVal FROM config WHERE configKey LIKE 'kb%';
```

### 自检清单

- 新增依赖：无（复用现有 `apiConfig` 与 Element Plus 组件）。
- 旧数据兼容：兼容。`config` 表无对应 key 时页面会显示为空/默认值；保存后会写入或更新对应 key。

### 测试指令（推荐）

- admin 编译验证：`cd 99AI-ANKI/admin && pnpm -s build`
- 启动后人工验证：登录 admin -> 存储配置 -> 知识库COS -> 填写并保存 -> 执行上面的 SQL 校验。

### 回滚策略

- UI 回滚：移除菜单/页面即可
- 数据回滚：删除对应 configKey（见 Step 7 回滚）

---

## Step 13：chat 端知识库栏（只读：配额 + 树 + 列表）

### 目标

- chat 页面增加常置顶知识库区域
- 接入 API：`/kb/quota`、`/kb/folders/tree`、`/kb/files`

### 验证方法

- 启动 chat，登录后检查：
  - 知识库栏出现
  - 配额条显示
  - 文件夹树/列表能加载

### 本步骤状态

- 已完成：侧边栏顶部新增“知识库”入口按钮（显示已用/总额/进度条），点击后从左侧弹出抽屉（宽约为侧栏 1.5 倍，高度同侧栏），展示只读管理界面（配额 + 文件夹树 + PDF 列表）。
- 已完成：优化抽屉内排版（增加留白与间距，列表卡片化显示）。
- 已完成：抽屉通过 `Teleport` 挂载到 `body`，作为顶层覆盖层展示（避免被侧边栏 `transform` 限制在侧栏区域内）。

涉及代码文件：

- [chat/src/api/kb.ts](../chat/src/api/kb.ts)（新增：quota/tree/files API 封装）
- [chat/src/views/chat/components/sider/KnowledgeBaseReadonly.vue](../chat/src/views/chat/components/sider/KnowledgeBaseReadonly.vue)（新增：按钮 + 弹窗窗格 + 数据加载）
- [chat/src/views/chat/components/sider/index.vue](../chat/src/views/chat/components/sider/index.vue)（修改：挂载知识库入口在对话列表上方）

### 自检清单

- 新增依赖：无（复用现有请求封装与 @icon-park/vue-next）。
- 旧数据兼容：兼容。无论是否存在 folder/pdf 数据，均以“暂无”展示；quota 为 0 时进度为 0。

### 测试指令（推荐）

- 编译验证：`cd 99AI-ANKI/chat && pnpm -s build`
- 本地运行验证：`cd 99AI-ANKI/chat && pnpm -s dev`（登录后点击侧边栏顶部“知识库”按钮，检查配额/树/列表加载）

### 回滚策略

- 前端 feature flag（临时）或直接移除该组件挂载

---

## Step 14：chat 端知识库栏（可写：新建/重命名/删除/上传/预览）

### 目标

- 接入 API：folder CRUD、上传、rename、delete、signed-url

### 验证方法

- 实操测试：
  - 新建文件夹 -> 上传 PDF -> 列表出现 -> 点击预览打开 signed-url -> 删除后用量减少

### 回滚策略

- 只保留只读能力（回退到 Step 13）

---

## Step 15：联调收尾（边界条件与一致性）

### 目标

- 配额不足时的错误提示与 UI 处理
- 同级重名处理
- 删除失败重试策略（可人工触发）

### 验证脚本

- 配额不足：把某用户套餐设为很小

```sql
UPDATE crami_package SET kbQuotaBytes = 1024 WHERE id = 1;
```

然后上传大于 1KB 的 PDF，应返回 400/413，并提示“空间不足”。

### 回滚策略

- 恢复套餐配额值

---

## 附：建议的错误码约定（便于前端处理）

- 400：业务校验失败（同名、非 PDF、空间不足、文件夹非空删除）
- 401：未登录
- 403：越权访问他人文件
- 413：文件过大（单文件上限）
- 429：上传频率过高
- 500：COS/DB 异常

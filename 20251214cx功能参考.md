# 功能参考（从现状到扩展）

## 现有请求链路概览

- **前端 chat（用户端）**
  - 调用 `chat/src/api/index.ts` 中的 `fetchChatAPIProcess`，POST `/chatgpt/chat-process`（带流式下载进度）。
  - 典型负载：`{ model, modelName, modelType, prompt, groupId, appId, fileUrl/imageUrl, options:{usingNetwork, usingMcpTool}, ... }`。
  - 上传文件用 `uploadFile`（POST `/upload/file?dir=...`，FormData）。
- **前端 admin（后台）**
  - 通过 `admin/src/api/index.ts` 统一 axios，附带 Bearer Token；如 `modules/chat.ts` 调用 `GET chatLog/chatAll` 查看聊天记录。
- **后端 service（NestJS）**
  - 路由前缀 `/api`，JWT 校验 `JwtAuthGuard`。
  - `ChatController` 下 `POST /chatgpt/chat-process` → `ChatService.chatProcess`：校验余额/会员、敏感词、记录 chatLog、选择模型、流式写入响应并更新日志；`/chatgpt/tts-process` 语音播报。
  - `UploadController` 下 `POST /upload/file`：限制 10MB，支持本地/S3/OSS/COS，返回可访问的文件 URL。

## 典型请求/响应形态

- **发起对话**：`Authorization: Bearer <token>`，JSON 体见上；服务器流式返回多行 JSON（含 `chatId`、片段文本、状态码等），前端按行解析。
- **上传文件**：FormData 字段 `file`；返回完整 URL，之后在 `fetchChatAPIProcess` 中作为 `fileUrl` 传给后端。

## 新增“PDF → Markdown 笔记”工作流（从快到深）

### 1) 最快落地：新增后端 API（只调用你已有的外部包装 API）

1. 在 service 新建模块或放在 `modules/upload`/`modules/chat` 下，比如 `modules/pdfNote/pdf-note.controller.ts` 与 service：

```ts
// pdf-note.controller.ts
@Controller('pdf-note')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class PdfNoteController {
  constructor(private readonly svc: PdfNoteService) {}

  @Post('generate')
  async generate(@Body() body: { fileUrl: string; title?: string }, @Req() req) {
    return this.svc.generate(body.fileUrl, body.title, req.user.id);
  }
}
```

```ts
// pdf-note.service.ts
@Injectable()
export class PdfNoteService {
  constructor(private readonly upload: UploadService) {}

  async generate(fileUrl: string, title: string, userId: number) {
    // 可选：记录频率/日志
    const resp = await axios.post(process.env.PDF_API_URL, { fileUrl, title, userId });
    if (!resp.data?.markdown) throw new HttpException('生成失败', 400);
    return { markdown: resp.data.markdown, fileUrl, title };
  }
}
```

2. 将模块加入 `AppModule`（或在 `modules/pdfNote/pdf-note.module.ts` 导出后被 `AppModule` 引入）。
3. 前端 chat 新增 API 包装：

```ts
// chat/src/api/pdfNote.ts
import { post } from '@/utils/request';
export const fetchPdfNote = (data: { fileUrl: string; title?: string }) =>
  post<{ markdown: string }>({ url: '/pdf-note/generate', data });
```

4. 前端流程：
   - 用现有 `uploadFile(file)` 拿到 `fileUrl`。
   - 调用 `fetchPdfNote({ fileUrl, title })`，展示返回的 Markdown。

### 2) 改进版：上传+生成一步到位

- 在 `PdfNoteController` 添加支持 multipart：

```ts
@Post('upload-and-generate')
@UseInterceptors(FileInterceptor('file'))
async uploadAndGenerate(@UploadedFile() file, @Req() req) {
  const fileUrl = await this.upload.uploadFile(file, 'pdf-notes', req.user);
  return this.generate(fileUrl, file.originalname, req.user.id);
}
```

- 前端直接 `FormData.append('file', file)` POST `/pdf-note/upload-and-generate`。

### 3) 与聊天记录联动（高级）

- 在 `PdfNoteService.generate` 内：
  - 调用 `chatLogService.saveChatLog` 创建用户提问/助手回复两条记录（类似 `ChatService.chatProcess`）。
  - 将生成的 markdown 作为助手回复内容，`status` 设为完成。
- 在前端：拿到 `chatId` 后把 markdown 插入当前对话流（可复用 chat 视图组件）。

### 4) 配置与安全

- 环境变量：`PDF_API_URL`、`PDF_API_KEY`（如需要）。
- 文件限制：复用上传大小/频率控制；必要时校验文件类型只允许 pdf。
- 权限：沿用 JWT，视情况限制会员或积分扣费，可借鉴 `ChatService` 的 `validateBalance`。

### 5) 推荐代码放置

- 目录：`service/src/modules/pdfNote/`（controller/service/dto/module）。
- 前端：
  - API 包装：`chat/src/api/pdfNote.ts`。
  - UI 触发：在上传入口（如会话侧栏/工具区）调用上传→生成→渲染结果。

## 验证步骤

- 本地启动后端：确保新模块被 `AppModule` 引入，Swagger（`ISDEV=true`）可测。
- 前端：用 mock 文件跑通上传+生成，检查返回 markdown 正确渲染；观察网络请求是否带 token，CORS 正常。
- 日志：确认 `chatlog` 有记录（若启用步骤 3），上传记录未超过频率限制。

## 现成接口的请求/响应示例

### 1) 对话 `/api/chatgpt/chat-process`

- `Authorization: Bearer <jwt>`
- `Content-Type: application/json`

```json
{
  "model": "gpt-4o",
  "modelName": "GPT-4o",
  "modelType": 1,
  "prompt": "请把这段文字总结成要点",
  "appId": null,
  "fileUrl": "https://cdn.example.com/file/202412/11/demo.pdf",  // 可选，上传后的地址
  "imageUrl": null,
  "extraParam": { "size": "1024x1024" },
  "options": { "groupId": 123, "usingNetwork": false, "usingMcpTool": false }
}
```

- 字段说明
  - `model`：要调用的大模型标识（如 `gpt-4o`），用于选择后端模型配置与计费策略。
  - `modelName`：前端显示用的模型名称，便于 UI 呈现。
  - `modelType`：模型类型/计费类型（数值枚举，影响扣费逻辑和日志标注）。
  - `prompt`：用户提问或指令文本。
  - `appId`：应用 ID，若绑定某个预设/会员应用则传入；为空表示通用对话。
  - `fileUrl`：已上传文件的访问 URL（如 PDF），后端会记录并在需要时做向量/检索。
  - `imageUrl`：已上传图片的 URL，支持视觉模型或图片上下文。
  - `extraParam`：附加参数对象（如图像尺寸等），透传给模型或插件。
  - `options.groupId`：对话分组 ID，用于关联历史上下文、标题生成等。
  - `options.usingNetwork`：是否启用联网搜索（影响后端工具调用与计费）。
  - `options.usingMcpTool`：是否启用 MCP 工具调用（后端会按需触发工具链）。
  - 第 1 行：分配的 `chatId`，如 `{"chatId": 456}`。
  - 中间多行：生成中的增量片段（`ChatService` 在 `onProgress` 回调里写出），形如：

    ```json
    {"chatId":456,"text":"你好，"}
    {"chatId":456,"text":"这是要点..."}
    ```
  - 最后一行：完整结果，包含扣费后余额等：

    ```json
    {
      "full_content": "1) 要点A 2) 要点B",
      "full_reasoning_content": "",          // 深度思考内容（部分模型提供）
      "tool_calls": [],
      "userBalance": 98.5,
      "chatId": 456,
      "promptReference": "{后续提问1}{后续提问2}{后续提问3}"
    }
    ```

### 2) 上传文件 `/api/upload/file`

- Headers
  - `Authorization: Bearer <jwt>`
  - `Content-Type: multipart/form-data`
- Payload（FormData）
  - `file`: 选中的文件（二进制）
  - `dir`（query，可选）: 目标目录，默认按日期 `userFiles/YYYYMM/DD`
- 响应（示例）

```json
"https://cdn.example.com/file/userFiles/202412/11/1733900000_abcd.pdf"
```

> 请求路径前缀：后端在 `main.ts` 里设置了全局 `/api`，前端 chat 调用 `/chatgpt/chat-process` 实际会请求 `/api/chatgpt/chat-process`。

### JWT 从哪里来/存哪

- 登录接口：`POST /api/auth/login`（或验证码登录 `loginWithCaptcha`，请求体见 `UserLoginDto`），返回值就是 JWT 字符串，前端拿这个拼到 `Authorization: Bearer <jwt>`。
- 颁发逻辑：`AuthService.login` 使用 `JwtService.sign({ username,id,email,role,openId,client,phone })` 生成；密钥 `JWT_SECRET` 在启动时写入 Redis（`main.ts` 用随机 256 字节 base64 保存为键 `JWT_SECRET`）。
- 存储位置：令牌本身不会入库，只缓存到 Redis（`RedisCacheService.saveToken(userId, token)`）；用户账号信息在数据库表 `user`（TypeORM `UserEntity`）。

### 用户 ID 获取与存储（用于 COS 目录）

- 用户表：`users`（实体 `service/src/modules/user/user.entity.ts`），主键 `id` 为数字自增 ID。
- JWT 载荷：`AuthService.login` 签发的 Token 中包含 `id` 字段，前端登录成功后拿到的 token 内即可解析出用户 ID。
- 后端请求态：所有带 `JwtAuthGuard` 的接口会把解析后的用户对象挂到 `req.user`，其中的 `id` 就是用户 ID，可用于构造路径如 `/<userId>/<pdfName>/<file>.pdf`。

## 用这些信息快速落地 FastAPI

- 已有信息能覆盖：路由/方法（`POST /api/chatgpt/chat-process`、`POST /api/upload/file`）、请求头（Bearer JWT）、请求体字段含义、流式响应形态、JWT 获取方式与 secret 来源。
- FastAPI 需自行实现的要点：
  1) 鉴权：中间件/依赖解析 `Authorization: Bearer <jwt>`，用同一 `JWT_SECRET` 校验。
  2) 流式响应：`StreamingResponse` 按行写 JSON（首行 chatId，中间增量，末行完整结果）。
  3) 上传：`UploadFile` + `File` 接收，存储到本地/S3/COS，返回可访问 URL。
  4) 业务调用：把 `prompt`/`fileUrl`/`imageUrl`/`extraParam` 透传到你的模型或外部工具；如需计费/日志自行设计表。
  5) CORS 与前缀：路由前缀 `/api`，启用 CORS 便于前端直连。
  6) 频率/安全：可加限流、大小/后缀黑名单、敏感词、余额校验等。
- 如果要完全对齐原行为，需再补：计费算法（modelType/token 计费）、chatlog schema、标题/推荐问题生成逻辑、上传安全策略等。
